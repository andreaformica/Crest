variables:
    IMAGE: crest-service
    VERSION: '1.2'
    REGISTRY: 'svomtest.svom.fr:5543'
#    REGISTRY: 'svomtest.svom.fr:5543'
    CONTAINER_IMAGE: $REGISTRY/$IMAGE:$VERSION
    WEB_CONTAINER_IMAGE: $REGISTRY/crest-ui:$VERSION
    GRADLE_OPTS: "-Dorg.gradle.daemon=false"
    GIT_SSL_NO_VERIFY: "true"

  # When using dind service we need to instruct docker, to talk with the
  # daemon started inside of the service. The daemon is available with
  # a network connection instead of the default /var/run/docker.sock socket.
  #
  # The 'docker' hostname is the alias of the service container as described at
  # https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#accessing-the-services
  #
  # Note that if you're using Kubernetes executor, the variable should be set to
  # tcp://localhost:2375 because of how Kubernetes executor connects services
  # to the job container
#    DOCKER_HOST: tcp://docker:2375/
  # When using dind, it's wise to use the overlayfs driver for
  # improved performance.
#    DOCKER_DRIVER: overlay2

# Select a runner
# use tag keyword (see below)

#services:
#  - docker:dind


# Make the gradle wrapper executable. This essentially downloads a copy of
# Gradle to build the project with.
# https://docs.gradle.org/current/userguide/gradle_wrapper.html
# It is expected that any modern gradle project has a wrapper
before_script:
  - chmod +x gradlew

# We redirect the gradle user home using -g so that it caches the
# wrapper and dependencies.
# https://docs.gradle.org/current/userguide/gradle_command_line.html
#
# Unfortunately it also caches the build output so
# cleaning removes reminants of any cached builds.
# The assemble task actually builds the project.
# If it fails here, the tests can't run.
#build:
#  stage: build
#  script:
#    - ./gradlew -g /cache/.gradle clean :crestdb-web:assemble -PwarName=crest.war
#  allow_failure: false

# Use the generated build output to run the tests.
#test:
#  stage: test
#  script:
#    - ./gradlew -g /cache/.gradle check

stages:
 - package_application
 - build
 - build_docker_image
 - release
 - sonar_application
 - redeploy

package_svom_application:
  stage: package_application
  image: adoptopenjdk:11-jdk-openj9
  script:
   - ./gradlew -g /cache/.gradle clean assemble -PwarName=crest.war
  allow_failure: false
  artifacts:
    paths:
    - ./crestdb-web/build/libs/crest.war
    expire_in: 1 week
  only:
  - cms-stable

release:
  stage: release
  image: docker:19.03.1
  services:
    - docker:19.03.1-dind
  before_script:
      - docker login -u svom -p $SVOMREGISTRYPSWD $REGISTRY
  script:
      - docker build --rm --tag=$CONTAINER_IMAGE --file Dockerfile .
      - docker push $CONTAINER_IMAGE
  only:
  - cms-stable

sonar_application:
  stage: sonar_application
  image: adoptopenjdk:11-jdk-openj9
  script:
   - ./gradlew sonarqube -Dsonar.projectKey=crestdb -Dsonar.host.url=http://svom1.lal.in2p3.fr:20090 -Dsonar.login=f50918d8b780181f947ae83b42e78983ffde4bf3
  allow_failure: false
  only:
  - stable

# build_svom_docker_image:
#   stage: build
#   environment: dc0
#   tags:
#     - dc0-shell
#   image: java:8
#   script:
#     - docker info
#     - docker build --tag=$CONTAINER_IMAGE --file Dockerfile.svom .
#   only:
#   - svom-dc1

# webui:
#   stage: webui
#   tags:
#     - dc0-shell
#   script:
#     - docker info
#     - docker build --tag=$WEB_CONTAINER_IMAGE ./web-ui/crest-ui/
#   only:
#   - svom-dc0

# registry-push:
#   stage: release
#   environment: dc0
#   tags:
#     - dc0-shell
#   script:
#     - docker login -u svom -p $SVOMREGISTRYPSWD $REGISTRY
#     - docker push $CONTAINER_IMAGE
#   only:
#   - svom-dc1

package_cern_application:
  stage: package_application
  environment: cern
  image: adoptopenjdk:11-jdk-openj9
  script:
   - ./gradlew -g /cache/.gradle clean assemble -PwarName=crest.war
  allow_failure: false
  artifacts:
   paths:
   - ./crestdb-web/build/libs/crest.war

build_docker_image_job:
  stage: build_docker_image
  environment: cern
  image:
    # We recommend using the CERN version of the Kaniko image: gitlab-registry.cern.ch/ci-tools/docker-image-builder
    name: gitlab-registry.cern.ch/ci-tools/docker-image-builder
    entrypoint: [""]
  script:
    - mkdir -p /kaniko/.docker
    # Prepare Kaniko configuration file
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
      # Build and push the image from the Dockerfile at the root of the project.
      # To push to a specific docker tag, amend the --destination parameter, e.g. --destination $CI_REGISTRY_IMAGE:$CI_BUILD_REF_NAME
    # See https://docs.gitlab.com/ee/ci/variables/predefined_variables.html#variables-reference for available variables
    - /kaniko/executor --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/Dockerfile --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
  allow_failure: false
  rules:
    - if: $DO_DOCKER_IMAGE == "yes" && $CI_PIPELINE_SOURCE != 'merge_request_event'

build_cern_docker_image:
  stage: build
  environment: cern
  only:
    refs:
      - master
    variables:
      - $REMOTE_NAME == "cern"
  tags:
   - docker-image-build
  script: "echo building $CI_REGISTRY_IMAGE:runner" # No empty scripts are allowed
  variables:
   TO: $CI_REGISTRY_IMAGE:latest # Where to push resulting image


redeploy:
  stage: redeploy
  environment: cern
  only:
    refs:
      - master
    variables:
      - $REMOTE_NAME == "cern"
  image: gitlab-registry.cern.ch/paas-tools/openshift-client:latest
  script: "oc import-image $IMAGE_NAME  --server=$SERVER --namespace $NAMESPACE --all --token=$IMAGE_IMPORT_TOKEN"
